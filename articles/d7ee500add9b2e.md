---
title: "pydantic-graphã®ä¸­ã‚’è¦‹ã‚‹"
emoji: "ğŸ‘»"
type: "tech"
topics: [Python, Pydantic, PydanticAI, Graphs]
published: true
published_at: 2025-06-30 08:00
---

pydantic-graphã®ä¸­ã®ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿ãªãŒã‚‰ã€ã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’è¦‹ã¦ã¿ã¾ã—ãŸã€‚

## æ¦‚è¦
AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚ã‚‹PydanticAIã®æ©Ÿèƒ½ã®ä¸€éƒ¨ã«pydantic-graphãŒã‚ã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€Pythonç”¨ã®éåŒæœŸã‚°ãƒ©ãƒ•ãŠã‚ˆã³ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’ä½œã‚‹ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ãŒã€ãªã‹ãªã‹ã“ã®æ©Ÿèƒ½å˜ä½“ã§ä½¿ç”¨ã™ã‚‹å ´é¢ã¯å°‘ãªã„ã¨æ€ã„ã¾ã™ã€‚
ä»Šå›ã¯ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã‚’[ã‚³ãƒ¼ãƒ‰](https://github.com/pydantic/pydantic-ai/tree/main/pydantic_graph)ã‚’è¿½ã„ãªãŒã‚‰è¦‹ã¦ã„ãã¾ã™ã€‚

æœ¬æ–‡ä¸­ã®ã‚³ãƒ¼ãƒ‰: https://github.com/hosimesi/code-for-techblogs/tree/main/pydanticai_graph

## PydanticAIã¨ã¯
[PydanticAI](https://ai.pydantic.dev/)ã¯ã€ç”ŸæˆAIã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹ãŸã‚ã®Pythonãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚å‰å›ã®è¨˜äº‹ã§ã‚‚å–ã‚Šæ‰±ã£ãŸã®ã§ã€è©³ã—ãã¯[å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://ai.pydantic.dev/)ã¨[ã“ã¡ã‚‰](https://zenn.dev/hosimesi/articles/4085071b920734)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## pydantic-graphã¨ã¯
PydanticAIã®æ©Ÿèƒ½ã®ä¸€éƒ¨ã§ã¯ã‚ã‚Šã¾ã™ãŒã€PydanticAIã«ä¾å­˜ã—ã¦ãŠã‚‰ãšã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå˜ä½“ã§å‹•ä½œã—ã¾ã™ã€‚ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚³ã‚¢ãªè€ƒãˆæ–¹ã¨ã—ã¦ã¯ã€ãƒãƒ¼ãƒ‰é–“ã®ç¹‹ãŒã‚Šã§ã‚ã‚‹ã‚¨ãƒƒã‚¸ã‚’ã€ãƒãƒ¼ãƒ‰ãŒè¿”ã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ãƒ’ãƒ³ãƒˆã¨ã—ã¦å®šç¾©ã—ã‚ˆã†ã¨ã„ã†ç‚¹ã§ã™ã€‚PydanticãŒå¾—æ„ã¨ã™ã‚‹å‹ãƒ’ãƒ³ãƒˆã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹ã“ã¨ã§ã€Pythonã§ã‚ã‚ŠãªãŒã‚‰ã‚ã‚‹ç¨‹åº¦å‹å®‰å…¨ã«è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚„ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚å…¬å¼ã§ã‚‚ã‚ã‚‹é€šã‚Šã€é«˜åº¦ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ä»¥å¤–ã§ã¯pydantic-graphã‚’ç›´æ¥ä½¿ã†ã®ã§ã¯ãªãã€PydanticAIã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚„ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ä½¿ã†ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
:::message alert
Don't use a nail gun unless you need a nail gun

If PydanticAI agents are a hammer, and multi-agent workflows are a sledgehammer, then graphs are a nail gun:
:::

## ç’°å¢ƒæ§‹ç¯‰
[uv](https://docs.astral.sh/uv/guides/install-python/)ã‚’ä½¿ç”¨ã—ã¦ç’°å¢ƒã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ã¾ãšã¯ã€å¿…è¦ã«ãªã‚‹pydantic-aiã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
```bash
$ uv init
```
```bash
$ uv add pydantic-graph
```
éåŒæœŸå®Ÿè¡Œã®ãŸã‚ã®asyncioã‚‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
```bash
$ uv add asyncio
```

## pydantic-graphã‚’å‹•ã‹ã—ã¦ã¿ã‚‹
ã¾ãšã¯ã€ç°¡å˜ã«pydantic-graphã‚’å‹•ã‹ã—ã¦ã¿ã¾ã™ã€‚ä¿¡å·ã®ç§»ã‚Šå¤‰ã‚ã‚Šã‚’è¡¨ã™ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ã¿ã¾ã™ã€‚AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¦ç´ ã¯å…¨ããªã„ã‚³ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ã¾ã™ãŒã€LLMã‚’å©ãAgentã‚’ä½¿ã£ãŸå ´åˆã‚‚åŸºæœ¬çš„ã«ã¯åŒã˜ã§ã™ã€‚
```Python:sample.py
import asyncio
from dataclasses import dataclass

from pydantic_graph import BaseNode, End, Graph, GraphRunContext


@dataclass
class TrafficState:
    current_color: str


@dataclass
class RedLight(BaseNode[TrafficState, None, str]):
    async def run(self, ctx: GraphRunContext) -> End[str]:
        print("èµ¤ä¿¡å·")
        await asyncio.sleep(1)
        return End("ã‚µã‚¤ã‚¯ãƒ«çµ‚äº†")


@dataclass
class YellowLight(BaseNode[TrafficState, None, str]):
    async def run(self, ctx: GraphRunContext) -> RedLight:
        print("é»„ä¿¡å·")
        await asyncio.sleep(1)
        return RedLight()


@dataclass
class GreenLight(BaseNode[TrafficState, None, str]):
    async def run(self, ctx: GraphRunContext) -> YellowLight:
        print("é’ä¿¡å·")
        await asyncio.sleep(1)
        return YellowLight()


traffic_graph = Graph(
    nodes=[GreenLight, YellowLight, RedLight],
    state_type=TrafficState,
    run_end_type=str,
)


async def main():
    initial_state = TrafficState(current_color="green")

    result = await traffic_graph.run(GreenLight(), state=initial_state)

    print(f"\næœ€çµ‚çµæœ: {result}")


if __name__ == "__main__":
    asyncio.run(main())
```

```text
é’ä¿¡å·
é»„ä¿¡å·
èµ¤ä¿¡å·

æœ€çµ‚çµæœ: GraphRunResult(output='ã‚µã‚¤ã‚¯ãƒ«çµ‚äº†', state=TrafficState(current_color='green'))
```
ã“ã®ã‚ˆã†ã«é¢ç™½ã„ç‚¹ã¨ã—ã¦ã¯ã€Graphã‚’å®šç¾©ã—ã¦runã™ã‚‹ã ã‘ã§NodeãŒé †ç•ªã«å®Ÿè¡Œã•ã‚Œã€ä¿¡å·ãŒå¤‰ã‚ã£ã¦ã„ãã®ãŒåˆ†ã‹ã‚‹ã‹ã¨æ€ã„ã¾ã™ã€‚
ã“ã®Graphã«ã‚ã‚‹NodeãŒé †ç•ªã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã«ã©ã†ã„ã†å®Ÿè£…ãŒã•ã‚Œã¦ã„ã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚


## pydantic-graphã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
pydantic-graphã§ã¯ä¸Šè¨˜ã®ã‚ˆã†ã«ãƒãƒ¼ãƒ‰ã‚’ç¹‹ã’ã¦ã€runã™ã‚‹ã ã‘ã§å„ãƒãƒ¼ãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã®ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ãŒãã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ãªã‚Šã¾ã™ã€‚
- `GraphRunContext`
  - å®Ÿè¡Œæ™‚ã«æ¸¡ã•ã‚Œã‚‹ã‚°ãƒ©ãƒ•ãƒ¬ãƒ™ãƒ«ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã€ã‚°ãƒ©ãƒ•ã®çŠ¶æ…‹ã‚„ä¾å­˜é–¢ä¿‚ã‚’æŒã¡ã¾ã™ã€‚
- `End`
  - ã‚°ãƒ©ãƒ•ã®å®Ÿè¡Œã®çµ‚äº†ã‚’è¡¨ã™ãŸã‚ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã™ã€‚
- `BaseNode`
  - Nodeã®ã‚³ã‚¢ã§ã‚ã‚Šã€é€šå¸¸Dataclassã§å®šç¾©ã•ã‚Œã¾ã™ã€‚
  - runãƒ¡ã‚½ãƒƒãƒ‰ã‚’å¿…ãšæŒã¡ã€ãã®ä¸­ã«å‡¦ç†ã‚’æ›¸ãã€æ¬¡ã®ãƒãƒ¼ãƒ‰ã®å‹ãƒ’ãƒ³ãƒˆã‚’è¿”ã—ã¾ã™ã€‚
- `Graph`
  - å®Ÿè¡Œã‚°ãƒ©ãƒ•ã§ã‚ã‚Šã€ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚
  - è¤‡æ•°ã®Nodeã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚
- `State`
  - åŸºæœ¬çš„ã«Dataclassã§æ§‹ç¯‰ã•ã‚Œã€Graphã®Stateã‚’ç®¡ç†ã—ã¾ã™ã€‚
- `BaseStatePersistence`
  - ãƒ‡ãƒ¼ã‚¿ã®æ°¸ç¶šåŒ–ã®ãŸã‚ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã‚ã‚Šã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¿å­˜ã¨å–å¾—ã‚’æ‹…ã„ã¾ã™ã€‚

## pydantic-graphã®ã‚³ã‚¢
Graphã‚’ä½œã£ã¦runã‚’ã™ã‚‹ã ã‘ã§å…¨ã¦ã®NodeãŒå®Ÿè¡Œã•ã‚Œã‚‹åŸç†ã‚’å®Ÿè£…ãƒ™ãƒ¼ã‚¹ã§ç¢ºèªã—ã¾ã™ã€‚å…ˆã»ã©æŒ™ã’ãŸä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã©ã®ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã€é€£æºã—ã¦ã„ã‚‹ã®ã‹ã‚’ã‚³ãƒ¼ãƒ‰ã‚’è¿½ã„ãªãŒã‚‰ç¢ºèªã—ã¾ã™ã€‚

### End
Endã¯å˜ãªã‚‹Dataclassã«ãªã£ã¦ã„ã¾ã™ã€‚å†…éƒ¨ã§ã¯snapshotã‚’å–ã£ãŸã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”Ÿãˆã¦ã„ã¾ã™ãŒåŸºæœ¬çš„ã«ã¯Endå‹ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚
```Python:pydantic_graph/node.py
@dataclass
class End(Generic[RunEndT]):
    """Type to return from a node to signal the end of the graph."""

    data: RunEndT
    """Data to return from the graph."""

    def deep_copy_data(self) -> End[RunEndT]:
        """Returns a deep copy of the end of the run."""
        if self.data is None:
            return self
        else:
            end = End(copy.deepcopy(self.data))
            end.set_snapshot_id(self.get_snapshot_id())
            return end

    def get_snapshot_id(self) -> str:
        if snapshot_id := getattr(self, '__snapshot_id', None):
            return snapshot_id
        else:
            self.__dict__['__snapshot_id'] = snapshot_id = generate_snapshot_id('end')
            return snapshot_id

    def set_snapshot_id(self, set_id: str) -> None:
        self.__dict__['__snapshot_id'] = set_id
```
ãã—ã¦Graphã®ã‚³ã‚¢ã§ã‚ã‚‹GraphRunå´ã§Nodeã®åˆ¤å®šã‚’ã—ã€Endã®å ´åˆã¯StopAsyncIterationã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã£ã¦Graphå´ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ­¢ã‚ã¾ã™ã€‚
```Python:pydantic_graph/graph.py
class GraphRun:
    def __init__(self, graph, start_node, state, ...):
        ...
    async def __anext__(self) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:
        """Use the last returned node as the input to `Graph.next`."""
        if not self._is_started:
            self._is_started = True
            return self._next_node

        if isinstance(self._next_node, End):
            raise StopAsyncIteration

        return await self.next(self._next_node)
```
### BaseNode
BaseNodeã¯Nodeã®ã‚³ã‚¢ã®ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€ä¸»è¦ãªéƒ¨åˆ†ã¯runãƒ¡ã‚½ãƒƒãƒ‰ã¨ãã®æˆ»ã‚Šå€¤ã®å‹ãƒ’ãƒ³ãƒˆã§ã™ã€‚å‹ãƒ’ãƒ³ãƒˆã«ã‚ˆã£ã¦æ˜ç¤ºçš„ã«æ¬¡ã®Nodeã‚’æŒ‡å®šã—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¸¡ã™ã“ã¨ã§ã€æ¬¡ã®Nodeã§ã‚‚runãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã¾ã™ã€‚runãƒ¡ã‚½ãƒƒãƒ‰ã¯ã¨ã¦ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã§ã€ã„ã‚ã‚†ã‚‹å‡¦ç†ã®ã‚³ã‚¢ã«ãªã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ãå ´æ‰€ã«ãªã‚Šã¾ã™ã€‚ã¤ã¾ã‚ŠLLMã‚’ä½¿ã£ã¦ä½•ã‹ã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…ã‚‚åŸºæœ¬çš„ã«ã¯ã“ã®ä¸­ã§æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚å…ˆã»ã©ã®Graphã§runã‚’ã™ã‚‹ã¨NodeãŒé †åºã«å¾“ã£ã¦å®Ÿè¡Œã•ã‚Œã‚‹éƒ¨åˆ†ã«ãªã‚Šã¾ã™ã€‚
```Python:pydantic_graph/node.py
class BaseNode(Generic[StateT, DepsT, RunEndT]):
    async def run(
        self,
        ctx: GraphRunContext[StateT, DepsT, RunEndT],
    ) -> Union["BaseNode[StateT, DepsT, RunEndT]", End[RunEndT]]:
        raise NotImplementedError
```

### State
Stateã¯å˜ãªã‚‹Dataclassã§ã‚ã‚Šã€ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ãƒ†ãƒŠã®å‹ã‚’å®šç¾©ã™ã‚‹ã ã‘ã«ãªã‚Šã¾ã™ã€‚ã“ã¡ã‚‰ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å®šç¾©ã—ã¦ã„ã‚‹ãŸã‚ã€å€¤ã‚’ã©ã“ã‹ã‚‰ã§ã‚‚æ›¸ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚ã“ã®Stateã‚’Graphå†…ã§ä½¿ãˆã‚‹ã‚ˆã†ã«GraphRunContextãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚
```Python:
from dataclasses import dataclass, field

@dataclass
class MyState:
    """ã‚°ãƒ©ãƒ•å…¨ä½“ã§å…±æœ‰ã•ã‚Œã‚‹çŠ¶æ…‹ã‚’å®šç¾©ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹"""
    counter: int = 0
    messages: list[str] = field(default_factory=list)
```

### GraphRunContext
GraphRunContextã¯Stateãªã©ã‚’æŒã£ãŸå˜ãªã‚‹Dataclassã§ã™ãŒã€å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³ã§ã‚ã‚‹GraphRunãŒå®Ÿè¡Œã•ã‚Œã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ç¾åœ¨ã®Stateã¸ã®å‚ç…§ã‚’ä¿æŒã—ã¦ãŠã‚Šã€ãƒãƒ¼ãƒ‰ã¯ã“ã®GraphRunContextã‚’é€šã˜ã¦Stateå±æ€§ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’æ“ä½œã—ã¾ã™ã€‚ã¾ãŸã€NodeãŒä¸€ã¤å®Ÿè¡Œã•ã‚Œã‚‹ãŸã³ã«æ¯å›æ–°ã—ãã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œã¾ã™ã€‚
```Python
@dataclass
class GraphRunContext(Generic[StateT, DepsT]):
    """Context for a graph."""

    # TODO: Can we get rid of this struct and just pass both these things around..?

    state: StateT
    """The state of the graph."""
    deps: DepsT
    """Dependencies for the graph."""
```
GraphRunãŒæ¬¡ã«å®Ÿè¡Œã™ã¹ããƒãƒ¼ãƒ‰ï¼ˆnodeï¼‰ã®runãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ç›´å‰ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
```Python
# pydantic_graph/graph.py ã® GraphRun.next ãƒ¡ã‚½ãƒƒãƒ‰ã«ç›¸å½“ã™ã‚‹éƒ¨åˆ†
class GraphRun(Generic[StateT, DepsT, RunEndT]):
    # ...
    async def next(
        self, node: BaseNode[StateT, DepsT, RunEndT] | None = None
    ) -> BaseNode[StateT, DepsT, RunEndT] | End[RunEndT]:
        ...

        with ExitStack() as stack:
            if self.graph.auto_instrument:
                stack.enter_context(_logfire.span('run node {node_id}', node_id=node_id, node=node))

            async with self.persistence.record_run(node_snapshot_id):
                ctx = GraphRunContext(self.state, self.deps) # <-
                self._next_node = await node.run(ctx)

        return self._next_node

```
ã“ã®å®Ÿè£…ã«ã‚ˆã£ã¦ã€å„ãƒãƒ¼ãƒ‰ã¯å¸¸ã«ãã®å®Ÿè¡Œæ™‚ç‚¹ã§ã®æœ€æ–°ã®Stateã‚’å–å¾—ã§ãã¾ã™ã€‚

### Graph
Graphã‚¯ãƒ©ã‚¹ã¯Nodeã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã¾ã¨ã‚ã¦ã€å®Ÿè¡Œãƒ•ãƒ­ãƒ¼å…¨ä½“ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
Graphè‡ªèº«ã¯å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ã‚’æŒãŸãšã«æº–å‚™ã‚’è¡Œãªã£ã¦ã€å®Ÿéš›ã®å‡¦ç†ã¯GraphRunã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä»»ã›ã¾ã™ã€‚
```Python:pydantic_graph/graph.py
@dataclass
class Graph(Generic[StateT, DepsT, RunEndT]):
    nodes: Sequence[type[BaseNode[StateT, DepsT, RunEndT]]]
    # ...

    async def run(
        self,
        start_node: BaseNode[StateT, DepsT, RunEndT],
        # ...
    ) -> GraphRunResult[StateT, RunEndT]:
        run = self.iter(start_node, ...)
        async for _ in run:
            pass
        return await run.result()

    def iter(
        self,
        start_node: BaseNode[StateT, DepsT, RunEndT],
        # ...
    ) -> GraphRun[StateT, DepsT, RunEndT]:
        return GraphRun(self, start_node, ...)
```
Graphã®å½¹å‰²ã¯å®Ÿè¡Œã«å¿…è¦ãªGraphRunã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ãã—ã¦ã€ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã§å®Ÿè¡Œã—ã¦ã„ãŸrunãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã“ã®GraphRunã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’async forã§å›ã™ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ãã—ã¦ã€Iterationã—ãŸGraphRunã®å®Ÿè¡Œé–¢æ•°ã¯å…ˆã»ã©GraphRunã§ã‚ã’ãŸ`async def next`ã«ãªã‚‹ãŸã‚ã€GraphRunContextã‚’æ¸¡ã—ã¤ã¤Nodeã‚’å®Ÿè¡Œã§ãã‚‹ã¨ã„ã†åŸç†ã§ã™ã€‚

## ã¾ã¨ã‚
æœ¬è¨˜äº‹ã§ã¯ã€pydantic-graphã®åŸºæœ¬çš„ãªä½¿ã„æ–¹ã¨å®Ÿè£…ã«ã¤ã„ã¦è¦‹ã¦ã¿ã¾ã—ãŸã€‚
pydantic-graphã¯ã€ãƒãƒ¼ãƒ‰ã®æˆ»ã‚Šå€¤ã®å‹ãƒ’ãƒ³ãƒˆã‚’åˆ©ç”¨ã—ã¦ã‚°ãƒ©ãƒ•ã®æ§‹é€ ã‚’å®šç¾©ã—ã€Iterationã”ã¨ã«Nodeã‚’å®Ÿè¡Œã™ã‚‹è¨­è¨ˆã«ã‚ˆã£ã¦ç›´æ„Ÿçš„ãªã‚³ãƒ¼ãƒ‰ã§è¤‡é›‘ãªéåŒæœŸå‡¦ç†ã‚„ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹å¼·åŠ›ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã ã¨ã„ã†ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚å€‹ã€…ã®çŠ¶æ…‹ï¼ˆãƒãƒ¼ãƒ‰ï¼‰ã®ãƒ­ã‚¸ãƒƒã‚¯ã¨ã€å…¨ä½“ã®é·ç§»ï¼ˆã‚°ãƒ©ãƒ•ï¼‰ã®ç®¡ç†ã‚’ç¶ºéº—ã«åˆ†é›¢ã§ãã‚‹ãŸã‚ã€è¦‹é€šã—ã®è‰¯ã„è¨­è¨ˆãŒå¯èƒ½ã ãªã¨æ€ã„ã¾ã—ãŸã€‚

## å‚è€ƒ
- https://github.com/pydantic/pydantic-ai/tree/main/pydantic_graph
- https://ai.pydantic.dev/graph/
